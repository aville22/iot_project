from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

import numpy as np
import pandas as pd


@dataclass
class PreprocessConfig:
    """
    Configuration for stream preprocessing.
    """
    # Missing data handling
    fill_method: str = "ffill_then_bfill"  # "ffill_then_bfill" or "interpolate"

    # Noise filtering
    apply_smoothing: bool = True
    smoothing_window: int = 5  # rolling window size (in samples)

    # Normalization
    apply_normalization: bool = False
    normalization_mode: str = "global_zscore"  # "global_zscore" or "per_patient_zscore"


VITAL_COLUMNS = ["heart_rate", "spo2", "sbp", "dbp"]


def _ensure_types(df: pd.DataFrame) -> pd.DataFrame:
    """
    Ensure canonical dtypes and sort order.
    """
    df = df.copy()
    df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
    df = df.sort_values(["patient_id", "timestamp"]).reset_index(drop=True)
    return df


def _fill_missing(df: pd.DataFrame, method: str) -> pd.DataFrame:
    """
    Fill missing values in vital columns.
    """
    df = df.copy()

    if method == "ffill_then_bfill":
        df[VITAL_COLUMNS] = (
            df.groupby("patient_id", group_keys=False)[VITAL_COLUMNS]
            .apply(lambda x: x.ffill().bfill())
        )
    elif method == "interpolate":
        df[VITAL_COLUMNS] = (
            df.groupby("patient_id", group_keys=False)[VITAL_COLUMNS]
            .apply(lambda x: x.interpolate(method="linear").ffill().bfill())
        )
    else:
        raise ValueError(f"Unknown fill_method: {method}")

    return df


def _smooth_signals(df: pd.DataFrame, window: int) -> pd.DataFrame:
    """
    Apply rolling mean smoothing per patient to reduce noise.
    """
    df = df.copy()

    def _roll(x: pd.DataFrame) -> pd.DataFrame:
        return x.rolling(window=window, min_periods=1).mean()

    df[VITAL_COLUMNS] = (
        df.groupby("patient_id", group_keys=False)[VITAL_COLUMNS]
        .apply(_roll)
    )
    return df


def _zscore(x: pd.Series) -> pd.Series:
    """
    Safe z-score (handles constant columns).
    """
    mean = x.mean()
    std = x.std(ddof=0)
    if std == 0 or np.isnan(std):
        return x * 0.0
    return (x - mean) / std


def _normalize(df: pd.DataFrame, mode: str) -> pd.DataFrame:
    """
    Normalize vital signals using z-score.
    """
    df = df.copy()

    if mode == "global_zscore":
        for col in VITAL_COLUMNS:
            df[col] = _zscore(df[col])
    elif mode == "per_patient_zscore":
        df[VITAL_COLUMNS] = (
            df.groupby("patient_id", group_keys=False)[VITAL_COLUMNS]
            .apply(lambda x: x.apply(_zscore))
        )
    else:
        raise ValueError(f"Unknown normalization_mode: {mode}")

    return df


def preprocess_stream(df: pd.DataFrame, config: Optional[PreprocessConfig] = None) -> pd.DataFrame:
    """
    Full preprocessing pipeline:
      1) type casting + sorting
      2) missing values handling
      3) noise filtering (optional)
      4) normalization (optional)

    Returns a cleaned DataFrame ready for windowing / information arrays.
    """
    if config is None:
        config = PreprocessConfig()

    df = _ensure_types(df)

    # Keep only required columns (but do not break if extra columns exist)
    required = {"patient_id", "timestamp", "risk_level", *VITAL_COLUMNS}
    missing_cols = required - set(df.columns)
    if missing_cols:
        raise ValueError(f"Missing required columns: {sorted(missing_cols)}")

    df = _fill_missing(df, method=config.fill_method)

    if config.apply_smoothing:
        df = _smooth_signals(df, window=config.smoothing_window)

    if config.apply_normalization:
        df = _normalize(df, mode=config.normalization_mode)

    return df
